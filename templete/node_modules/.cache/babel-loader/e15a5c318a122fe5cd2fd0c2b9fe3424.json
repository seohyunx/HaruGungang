{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _buffer = require(\"./buffer\");\nvar n = require(\"./node\");\nvar _t = require(\"@babel/types\");\nvar generatorFunctions = require(\"./generators\");\nconst {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration\n} = _t;\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\nconst {\n  needsParens\n} = n;\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._indentChar = 0;\n    this._indentRepeat = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new Set();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this._lastCommentLine = 0;\n    this._endsWithInnerRaw = false;\n    this._indentInnerComments = true;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n    this._inputMap = map == null ? void 0 : map._inputMap;\n  }\n  generate(ast) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n    return this._buf.get();\n  }\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(59);\n    } else {\n      this._queue(59);\n    }\n    this._noLineTerminator = false;\n  }\n  rightBrace(node) {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.tokenChar(125);\n  }\n  rightParens(node) {\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.tokenChar(41);\n  }\n  space(force = false) {\n    if (this.format.compact) return;\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n  word(str, noLineTerminatorAfter = false) {\n    this._maybePrintInnerComments();\n    if (this._endsWithWord || str.charCodeAt(0) === 47 && this.endsWith(47)) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, false);\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n  token(str, maybeNewline = false) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (lastChar === 33 && (str === \"--\" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n  tokenChar(char) {\n    this._maybePrintInnerComments();\n    const lastChar = this.getLastChar();\n    if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {\n      this._space();\n    }\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n  newline(i = 1, force) {\n    if (i <= 0) return;\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n    if (i > 2) i = 2;\n    i -= this._buf.getNewlineCount();\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n    return;\n  }\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n  exactSource(loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(\"start\", loc);\n    this._buf.exactSource(loc, cb);\n  }\n  source(prop, loc) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.source(prop, loc);\n  }\n  sourceWithOffset(prop, loc, lineOffset, columnOffset) {\n    if (!loc) return;\n    this._catchUp(prop, loc);\n    this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);\n  }\n  withSource(prop, loc, cb) {\n    if (!loc) {\n      cb();\n      return;\n    }\n    this._catchUp(prop, loc);\n    this._buf.withSource(prop, loc, cb);\n  }\n  sourceIdentifierName(identifierName, pos) {\n    if (!this._buf._canMarkIdName) return;\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n  _space() {\n    this._queue(32);\n  }\n  _newline() {\n    this._queue(10);\n  }\n  _append(str, maybeNewline) {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n    this._buf.append(str, maybeNewline);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _appendChar(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.appendChar(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _queue(char) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n    this._buf.queue(char);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n  _maybeIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n  _shouldIndent(firstChar) {\n    if (this._indent && firstChar !== 10 && this.endsWith(10)) {\n      return true;\n    }\n  }\n  _maybeAddParenChar(char) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    if (char === 32) {\n      return;\n    }\n    if (char !== 10) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    const len = str.length;\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === 32; i++) continue;\n    if (i === len) {\n      return;\n    }\n    const cha = str.charCodeAt(i);\n    if (cha !== 10) {\n      if (cha !== 47 || i + 1 === len) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n      const chaPost = str.charCodeAt(i + 1);\n      if (chaPost === 42) {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          return;\n        }\n      } else if (chaPost !== 47) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n    this.tokenChar(40);\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n  catchUp(line) {\n    if (!this.format.retainLines) return;\n    const count = line - this._buf.getCurrentLine();\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n  _catchUp(prop, loc) {\n    var _loc$prop;\n    if (!this.format.retainLines) return;\n    const line = loc == null ? void 0 : (_loc$prop = loc[prop]) == null ? void 0 : _loc$prop.line;\n    if (line != null) {\n      const count = line - this._buf.getCurrentLine();\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n  _getIndent() {\n    return this._indentRepeat * this._indent;\n  }\n  printTerminatorless(node, parent, isLabel) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.tokenChar(41);\n      }\n    }\n  }\n  print(node, parent, noLineTerminatorAfter, trailingCommentsLineOffset, forceParens) {\n    var _node$extra;\n    if (!node) return;\n    this._endsWithInnerRaw = false;\n    const nodeType = node.type;\n    const format = this.format;\n    const oldConcise = format.concise;\n    if (node._compact) {\n      format.concise = true;\n    }\n    const printMethod = this[nodeType];\n    if (printMethod === undefined) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node.constructor.name)}`);\n    }\n    this._printStack.push(node);\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n    const shouldPrintParens = forceParens || format.retainFunctionParens && nodeType === \"FunctionExpression\" && ((_node$extra = node.extra) == null ? void 0 : _node$extra.parenthesized) || needsParens(node, parent, this._printStack);\n    if (shouldPrintParens) {\n      this.tokenChar(40);\n      this._endsWithInnerRaw = false;\n    }\n    this._lastCommentLine = 0;\n    this._printLeadingComments(node, parent);\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.tokenChar(41);\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n    this._printStack.pop();\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n    this._endsWithInnerRaw = false;\n  }\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      }, 0);\n    }\n  }\n  getPossibleRaw(node) {\n    const extra = node.extra;\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    let {\n      indent\n    } = opts;\n    if (indent == null && this.format.retainLines) {\n      var _nodes$0$loc;\n      const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n    if (indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0\n    };\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n      opts.iterator == null ? void 0 : opts.iterator(node, i);\n      if (i < len - 1) separator == null ? void 0 : separator();\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          var _nextNode$loc;\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n    if (indent) this.dedent();\n  }\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n  printBlock(parent) {\n    const node = parent.body;\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n    this.print(node, parent);\n  }\n  _printTrailingComments(node, parent, lineOffset) {\n    const {\n      innerComments,\n      trailingComments\n    } = node;\n    if (innerComments != null && innerComments.length) {\n      this._printComments(2, innerComments, node, parent, lineOffset);\n    }\n    if (trailingComments != null && trailingComments.length) {\n      this._printComments(2, trailingComments, node, parent, lineOffset);\n    }\n  }\n  _printLeadingComments(node, parent) {\n    const comments = node.leadingComments;\n    if (!(comments != null && comments.length)) return;\n    this._printComments(0, comments, node, parent);\n  }\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!(comments != null && comments.length)) return;\n    const hasSpace = this.endsWith(32);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(1, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n  printSequence(nodes, parent, opts = {}) {\n    var _opts$indent;\n    opts.statement = true;\n    (_opts$indent = opts.indent) != null ? _opts$indent : opts.indent = false;\n    this.printJoin(nodes, parent, opts);\n  }\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n    this.printJoin(items, parent, opts);\n  }\n  _printNewline(newLine, opts) {\n    const format = this.format;\n    if (format.retainLines || format.compact) return;\n    if (format.concise) {\n      this.space();\n      return;\n    }\n    if (!newLine) {\n      return;\n    }\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n    if (this._buf.hasContent()) {\n      this.newline(1);\n    }\n  }\n  _shouldPrintComment(comment) {\n    if (comment.ignore) return 0;\n    if (this._printedComments.has(comment)) return 0;\n    if (this._noLineTerminator && (HAS_NEWLINE.test(comment.value) || HAS_BlOCK_COMMENT_END.test(comment.value))) {\n      return 2;\n    }\n    this._printedComments.add(comment);\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return 0;\n    }\n    return 1;\n  }\n  _printComment(comment, skipNewLines) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {\n      this.newline(1);\n    }\n    const lastCharCode = this.getLastChar();\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        var _comment$loc;\n        const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n        let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();\n        if (this._shouldIndent(47) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      val = `/*${comment.value}*/`;\n    }\n    if (this.endsWith(47)) this._space();\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n    if (printNewLines && skipNewLines !== 3) {\n      this.newline(1);\n    }\n  }\n  _printComments(type, comments, node, parent, lineOffset = 0) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n    const maybeNewline = this._noLineTerminator ? function () {} : this.newline.bind(this);\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === 2) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === 1) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === 0) {\n          let offset = 0;\n          if (i === 0) {\n            if (this._buf.hasContent() && (comment.type === \"CommentLine\" || commentStartLine != commentEndLine)) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));\n            lastLine = nodeStartLine;\n          }\n        } else if (type === 1) {\n          const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine));\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n          maybeNewline(offset);\n          this._printComment(comment, 1);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== 1) {\n          continue;\n        }\n        if (len === 1) {\n          const singleLine = comment.loc ? comment.loc.start.line === comment.loc.end.line : !HAS_NEWLINE.test(comment.value);\n          const shouldSkipNewline = singleLine && !isStatement(node) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumDeclaration(parent);\n          if (type === 0) {\n            this._printComment(comment, shouldSkipNewline && node.type !== \"ObjectExpression\" || singleLine && isFunction(parent, {\n              body: node\n            }) ? 1 : 0);\n          } else if (shouldSkipNewline && type === 2) {\n            this._printComment(comment, 1);\n          } else {\n            this._printComment(comment, 0);\n          }\n        } else if (type === 1 && !(node.type === \"ObjectExpression\" && node.properties.length > 1) && node.type !== \"ClassBody\" && node.type !== \"TSInterfaceBody\") {\n          this._printComment(comment, i === 0 ? 2 : i === len - 1 ? 3 : 0);\n        } else {\n          this._printComment(comment, 0);\n        }\n      }\n    }\n    if (type === 2 && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\nfunction commaSeparator() {\n  this.tokenChar(44);\n  this.space();\n}","map":{"version":3,"sources":["../src/printer.ts"],"names":["isFunction","isStatement","isClassBody","isTSInterfaceBody","isTSEnumDeclaration","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","HAS_NEWLINE","HAS_BlOCK_COMMENT_END","needsParens","n","Printer","constructor","format","map","_buf","Buffer","_indentChar","indent","style","charCodeAt","_indentRepeat","length","_inputMap","inForStatementInitCounter","_printStack","_indent","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","Set","_endsWithInteger","_endsWithWord","_lastCommentLine","_endsWithInnerRaw","_indentInnerComments","generate","ast","print","_maybeAddAuxComment","get","compact","concise","dedent","semicolon","force","_appendChar","_queue","rightBrace","node","minified","removeLastSemicolon","sourceWithOffset","loc","token","rightParens","space","_space","hasContent","lastCp","getLastChar","word","str","noLineTerminatorAfter","_maybePrintInnerComments","endsWith","_append","number","Number","isInteger","test","maybeNewline","lastChar","strFirst","tokenChar","char","newline","i","retainLines","getNewlineCount","j","_newline","endsWithCharAndNewline","removeTrailingNewline","exactSource","cb","_catchUp","source","prop","lineOffset","columnOffset","withSource","sourceIdentifierName","identifierName","pos","_canMarkIdName","sourcePosition","_sourcePosition","identifierNamePos","_maybeAddParen","_maybeIndent","append","_maybeAddParenChar","appendChar","queue","firstChar","queueIndentation","_getIndent","_shouldIndent","parenPushNewlineState","printed","len","cha","chaPost","slice","catchUp","line","count","getCurrentLine","printTerminatorless","parent","isLabel","terminatorState","trailingCommentsLineOffset","forceParens","nodeType","type","oldConcise","_compact","printMethod","undefined","ReferenceError","JSON","stringify","name","push","oldInAux","shouldPrintParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","bind","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","value","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","startLine","start","newlineOpts","addNewlines","nextNodeStartLine","separator","statement","_printNewline","iterator","nextNode","printAndIndentOnComments","leadingComments","printBlock","body","innerComments","trailingComments","_printComments","comments","printInnerComments","hasSpace","printedCommentsCount","size","noIndentInnerCommentsHere","printSequence","printList","items","commaSeparator","newLine","lastCommentLine","offset","_shouldPrintComment","ignore","has","add","shouldPrintComment","skipNewLines","noLineTerminator","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","column","newlineRegex","RegExp","replace","indentSize","getCurrentColumn","repeat","nodeLoc","hasLoc","nodeStartLine","nodeEndLine","end","lastLine","leadingCommentNewline","shouldPrint","commentStartLine","commentEndLine","Math","max","min","singleLine","shouldSkipNewline","properties","Object","assign","prototype","generatorFunctions","Noop","exports"],"mappings":";;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AAEA,IAAA,CAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AAEA,IAAA,EAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAaA,IAAA,kBAAA,GAAA,OAAA,CAAA,cAAA,CAAA;AAAmD,MAAA;EAZjDA,UAAU;EACVC,WAAW;EACXC,WAAW;EACXC,iBAAiB;EACjBC;AAAmB,CAAA,GAAA,EAAA;AAarB,MAAMC,mBAAmB,GAAG,IAAI;AAChC,MAAMC,oBAAoB,GAAG,OAAO;AACpC,MAAMC,mBAAmB,GAAG,SAAS;AACrC,MAAMC,kBAAkB,GAAG,sBAAsB;AACjD,MAAMC,WAAW,GAAG,oBAAoB;AACxC,MAAMC,qBAAqB,GAAG,MAAM;AAEpC,MAAM;EAAEC;AAAY,CAAC,GAAGC,CAAC;AA8EzB,MAAMC,OAAO,CAAC;EACZC,WAAWA,CAACC,MAAc,EAAEC,GAAc,EAAE;IAAA,IAAA,CAY5CU,yBAAyB,GAAW,CAAC;IAAA,IAAA,CAGrCC,WAAW,GAAkB,EAAE;IAAA,IAAA,CAC/BC,OAAO,GAAW,CAAC;IAAA,IAAA,CACnBT,WAAW,GAAW,CAAC;IAAA,IAAA,CACvBI,aAAa,GAAW,CAAC;IAAA,IAAA,CACzBM,UAAU,GAAY,KAAK;IAAA,IAAA,CAC3BC,sBAAsB,GAAgC,IAAI;IAAA,IAAA,CAC1DC,iBAAiB,GAAY,KAAK;IAAA,IAAA,CAClCC,4BAA4B,GAAY,KAAK;IAAA,IAAA,CAC7CC,gBAAgB,GAAG,IAAIC,GAAG,CAAY,CAAC;IAAA,IAAA,CACvCC,gBAAgB,GAAG,KAAK;IAAA,IAAA,CACxBC,aAAa,GAAG,KAAK;IAAA,IAAA,CACrBC,gBAAgB,GAAG,CAAC;IAAA,IAAA,CACpBC,iBAAiB,GAAY,KAAK;IAAA,IAAA,CAClCC,oBAAoB,GAAY,IAAI;IA3BlC,IAAI,CAACxB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACE,IAAI,GAAG,IAAIC,OAAAA,CAAAA,OAAM,CAACF,GAAG,CAAC;IAE3B,IAAI,CAACG,WAAW,GAAGJ,MAAM,CAACK,MAAM,CAACC,KAAK,CAACC,UAAU,CAAC,CAAC,CAAC;IACpD,IAAI,CAACC,aAAa,GAAGR,MAAM,CAACK,MAAM,CAACC,KAAK,CAACG,MAAM;IAE/C,IAAI,CAACC,SAAS,GAAGT,GAAG,IAAA,IAAA,GAAA,KAAA,CAAA,GAAHA,GAAG,CAAES,SAAS;EACjC;EAsBAe,QAAQA,CAACC,GAAW,EAAE;IACpB,IAAI,CAACC,KAAK,CAACD,GAAG,CAAC;IACf,IAAI,CAACE,mBAAmB,CAAC,CAAC;IAE1B,OAAO,IAAI,CAAC1B,IAAI,CAAC2B,GAAG,CAAC,CAAC;EACxB;EAMAxB,MAAMA,CAAAA,EAAS;IACb,IAAI,IAAI,CAACL,MAAM,CAAC8B,OAAO,IAAI,IAAI,CAAC9B,MAAM,CAAC+B,OAAO,EAAE;IAEhD,IAAI,CAAClB,OAAO,EAAE;EAChB;EAMAmB,MAAMA,CAAAA,EAAS;IACb,IAAI,IAAI,CAAChC,MAAM,CAAC8B,OAAO,IAAI,IAAI,CAAC9B,MAAM,CAAC+B,OAAO,EAAE;IAEhD,IAAI,CAAClB,OAAO,EAAE;EAChB;EAMAoB,SAASA,CAACC,KAAc,GAAG,KAAK,EAAQ;IACtC,IAAI,CAACN,mBAAmB,CAAC,CAAC;IAC1B,IAAIM,KAAK,EAAE;MACT,IAAI,CAACC,WAAW,CAAA,EAAoB,CAAC;IACvC,CAAC,MAAM;MACL,IAAI,CAACC,MAAM,CAAA,EAAoB,CAAC;IAClC;IACA,IAAI,CAACpB,iBAAiB,GAAG,KAAK;EAChC;EAMAqB,UAAUA,CAACC,IAAY,EAAQ;IAC7B,IAAI,IAAI,CAACtC,MAAM,CAACuC,QAAQ,EAAE;MACxB,IAAI,CAACrC,IAAI,CAACsC,mBAAmB,CAAC,CAAC;IACjC;IACA,IAAI,CAACC,gBAAgB,CAAC,KAAK,EAAEH,IAAI,CAACI,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7C,IAAI,CAACC,SAAK,CAAA,GAAI,CAAC;EACjB;EAEAC,WAAWA,CAACN,IAAY,EAAQ;IAC9B,IAAI,CAACG,gBAAgB,CAAC,KAAK,EAAEH,IAAI,CAACI,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IAC7C,IAAI,CAACC,SAAK,CAAA,EAAI,CAAC;EACjB;EAMAE,KAAKA,CAACX,KAAc,GAAG,KAAK,EAAQ;IAClC,IAAI,IAAI,CAAClC,MAAM,CAAC8B,OAAO,EAAE;IAEzB,IAAII,KAAK,EAAE;MACT,IAAI,CAACY,MAAM,CAAC,CAAC;IACf,CAAC,MAAM,IAAI,IAAI,CAAC5C,IAAI,CAAC6C,UAAU,CAAC,CAAC,EAAE;MACjC,MAAMC,MAAM,GAAG,IAAI,CAACC,WAAW,CAAC,CAAC;MACjC,IAAID,MAAM,KAAA,EAAoB,IAAIA,MAAM,KAAA,EAAuB,EAAE;QAC/D,IAAI,CAACF,MAAM,CAAC,CAAC;MACf;IACF;EACF;EAMAI,IAAIA,CAACC,GAAW,EAAEC,qBAA8B,GAAG,KAAK,EAAQ;IAC9D,IAAI,CAACC,wBAAwB,CAAC,CAAC;IAG/B,IACE,IAAI,CAAChC,aAAa,IACjB8B,GAAG,CAAC5C,UAAU,CAAC,CAAC,CAAC,KAAA,EAAoB,IAAI,IAAI,CAAC+C,QAAQ,CAAA,EAAgB,CAAE,EACzE;MACA,IAAI,CAACR,MAAM,CAAC,CAAC;IACf;IAEA,IAAI,CAAClB,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAAC2B,OAAO,CAACJ,GAAG,EAAE,KAAK,CAAC;IAExB,IAAI,CAAC9B,aAAa,GAAG,IAAI;IACzB,IAAI,CAACL,iBAAiB,GAAGoC,qBAAqB;EAChD;EAMAI,MAAMA,CAACL,GAAW,EAAQ;IACxB,IAAI,CAACD,IAAI,CAACC,GAAG,CAAC;IAId,IAAI,CAAC/B,gBAAgB,GACnBqC,MAAM,CAACC,SAAS,CAAC,CAACP,GAAG,CAAC,IACtB,CAAC3D,mBAAmB,CAACmE,IAAI,CAACR,GAAG,CAAC,IAC9B,CAAC7D,mBAAmB,CAACqE,IAAI,CAACR,GAAG,CAAC,IAC9B,CAAC5D,oBAAoB,CAACoE,IAAI,CAACR,GAAG,CAAC,IAC/BA,GAAG,CAAC5C,UAAU,CAAC4C,GAAG,CAAC1C,MAAM,GAAG,CAAC,CAAC,KAAA,EAAkB;EACpD;EAKAkC,KAAKA,CAACQ,GAAW,EAAES,YAAY,GAAG,KAAK,EAAQ;IAC7C,IAAI,CAACP,wBAAwB,CAAC,CAAC;IAE/B,MAAMQ,QAAQ,GAAG,IAAI,CAACZ,WAAW,CAAC,CAAC;IACnC,MAAMa,QAAQ,GAAGX,GAAG,CAAC5C,UAAU,CAAC,CAAC,CAAC;IAClC,IACGsD,QAAQ,KAAA,EAA8B,KAGpCV,GAAG,KAAK,IAAI,IAEXW,QAAQ,KAAA,EAAuB,CAAC,IAEnCA,QAAQ,KAAA,EAAuB,IAAID,QAAQ,KAAA,EAAwB,IACnEC,QAAQ,KAAA,EAAmB,IAAID,QAAQ,KAAA,EAAoB,IAE3DC,QAAQ,KAAA,EAAkB,IAAI,IAAI,CAAC1C,gBAAiB,EACrD;MACA,IAAI,CAAC0B,MAAM,CAAC,CAAC;IACf;IAEA,IAAI,CAAClB,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAAC2B,OAAO,CAACJ,GAAG,EAAES,YAAY,CAAC;IAC/B,IAAI,CAAC5C,iBAAiB,GAAG,KAAK;EAChC;EAEA+C,SAASA,CAACC,IAAY,EAAQ;IAC5B,IAAI,CAACX,wBAAwB,CAAC,CAAC;IAE/B,MAAMQ,QAAQ,GAAG,IAAI,CAACZ,WAAW,CAAC,CAAC;IACnC,IAEGe,IAAI,KAAA,EAAuB,IAAIH,QAAQ,KAAA,EAAuB,IAC9DG,IAAI,KAAA,EAAmB,IAAIH,QAAQ,KAAA,EAAoB,IAEvDG,IAAI,KAAA,EAAkB,IAAI,IAAI,CAAC5C,gBAAiB,EACjD;MACA,IAAI,CAAC0B,MAAM,CAAC,CAAC;IACf;IAEA,IAAI,CAAClB,mBAAmB,CAAC,CAAC;IAC1B,IAAI,CAACO,WAAW,CAAC6B,IAAI,CAAC;IACtB,IAAI,CAAChD,iBAAiB,GAAG,KAAK;EAChC;EAQAiD,OAAOA,CAACC,CAAS,GAAG,CAAC,EAAEhC,KAAe,EAAQ;IAC5C,IAAIgC,CAAC,IAAI,CAAC,EAAE;IAEZ,IAAI,CAAChC,KAAK,EAAE;MACV,IAAI,IAAI,CAAClC,MAAM,CAACmE,WAAW,IAAI,IAAI,CAACnE,MAAM,CAAC8B,OAAO,EAAE;MAEpD,IAAI,IAAI,CAAC9B,MAAM,CAAC+B,OAAO,EAAE;QACvB,IAAI,CAACc,KAAK,CAAC,CAAC;QACZ;MACF;IACF;IAEA,IAAIqB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAC;IAEhBA,CAAC,IAAI,IAAI,CAAChE,IAAI,CAACkE,eAAe,CAAC,CAAC;IAEhC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,CAAC,EAAEG,CAAC,EAAE,EAAE;MAC1B,IAAI,CAACC,QAAQ,CAAC,CAAC;IACjB;IAEA;EACF;EAEAhB,QAAQA,CAACU,IAAY,EAAW;IAC9B,OAAO,IAAI,CAACf,WAAW,CAAC,CAAC,KAAKe,IAAI;EACpC;EAEAf,WAAWA,CAAAA,EAAW;IACpB,OAAO,IAAI,CAAC/C,IAAI,CAAC+C,WAAW,CAAC,CAAC;EAChC;EAEAsB,sBAAsBA,CAAAA,EAAW;IAC/B,OAAO,IAAI,CAACrE,IAAI,CAACqE,sBAAsB,CAAC,CAAC;EAC3C;EAEAC,qBAAqBA,CAAAA,EAAS;IAC5B,IAAI,CAACtE,IAAI,CAACsE,qBAAqB,CAAC,CAAC;EACnC;EAEAC,WAAWA,CAAC/B,GAAoB,EAAEgC,EAAc,EAAE;IAChD,IAAI,CAAChC,GAAG,EAAE;MACRgC,EAAE,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAACC,QAAQ,CAAC,OAAO,EAAEjC,GAAG,CAAC;IAE3B,IAAI,CAACxC,IAAI,CAACuE,WAAW,CAAC/B,GAAG,EAAEgC,EAAE,CAAC;EAChC;EAEAE,MAAMA,CAACC,IAAqB,EAAEnC,GAAoB,EAAQ;IACxD,IAAI,CAACA,GAAG,EAAE;IAEV,IAAI,CAACiC,QAAQ,CAACE,IAAI,EAAEnC,GAAG,CAAC;IAExB,IAAI,CAACxC,IAAI,CAAC0E,MAAM,CAACC,IAAI,EAAEnC,GAAG,CAAC;EAC7B;EAEAD,gBAAgBA,CACdoC,IAAqB,EACrBnC,GAAoB,EACpBoC,UAAkB,EAClBC,YAAoB,EACd;IACN,IAAI,CAACrC,GAAG,EAAE;IAEV,IAAI,CAACiC,QAAQ,CAACE,IAAI,EAAEnC,GAAG,CAAC;IAExB,IAAI,CAACxC,IAAI,CAACuC,gBAAgB,CAACoC,IAAI,EAAEnC,GAAG,EAAEoC,UAAU,EAAEC,YAAY,CAAC;EACjE;EAEAC,UAAUA,CACRH,IAAqB,EACrBnC,GAAoB,EACpBgC,EAAc,EACR;IACN,IAAI,CAAChC,GAAG,EAAE;MACRgC,EAAE,CAAC,CAAC;MACJ;IACF;IAEA,IAAI,CAACC,QAAQ,CAACE,IAAI,EAAEnC,GAAG,CAAC;IAExB,IAAI,CAACxC,IAAI,CAAC8E,UAAU,CAACH,IAAI,EAAEnC,GAAG,EAAEgC,EAAE,CAAC;EACrC;EAEAO,oBAAoBA,CAACC,cAAsB,EAAEC,GAAS,EAAQ;IAC5D,IAAI,CAAC,IAAI,CAACjF,IAAI,CAACkF,cAAc,EAAE;IAE/B,MAAMC,cAAc,GAAG,IAAI,CAACnF,IAAI,CAACoF,eAAe;IAChDD,cAAc,CAACE,iBAAiB,GAAGJ,GAAG;IACtCE,cAAc,CAACH,cAAc,GAAGA,cAAc;EAChD;EAEApC,MAAMA,CAAAA,EAAS;IACb,IAAI,CAACV,MAAM,CAAA,EAAgB,CAAC;EAC9B;EAEAkC,QAAQA,CAAAA,EAAS;IACf,IAAI,CAAClC,MAAM,CAAA,EAAmB,CAAC;EACjC;EAEAmB,OAAOA,CAACJ,GAAW,EAAES,YAAqB,EAAQ;IAChD,IAAI,CAAC4B,cAAc,CAACrC,GAAG,CAAC;IACxB,IAAI,CAACsC,YAAY,CAACtC,GAAG,CAAC5C,UAAU,CAAC,CAAC,CAAC,CAAC;IAEpC,IAAI,CAACL,IAAI,CAACwF,MAAM,CAACvC,GAAG,EAAES,YAAY,CAAC;IAEnC,IAAI,CAACvC,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACD,gBAAgB,GAAG,KAAK;EAC/B;EAEAe,WAAWA,CAAC6B,IAAY,EAAQ;IAC9B,IAAI,CAAC2B,kBAAkB,CAAC3B,IAAI,CAAC;IAC7B,IAAI,CAACyB,YAAY,CAACzB,IAAI,CAAC;IAEvB,IAAI,CAAC9D,IAAI,CAAC0F,UAAU,CAAC5B,IAAI,CAAC;IAE1B,IAAI,CAAC3C,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACD,gBAAgB,GAAG,KAAK;EAC/B;EAEAgB,MAAMA,CAAC4B,IAAY,EAAE;IACnB,IAAI,CAAC2B,kBAAkB,CAAC3B,IAAI,CAAC;IAC7B,IAAI,CAACyB,YAAY,CAACzB,IAAI,CAAC;IAEvB,IAAI,CAAC9D,IAAI,CAAC2F,KAAK,CAAC7B,IAAI,CAAC;IAErB,IAAI,CAAC3C,aAAa,GAAG,KAAK;IAC1B,IAAI,CAACD,gBAAgB,GAAG,KAAK;EAC/B;EAEAqE,YAAYA,CAACK,SAAiB,EAAQ;IAEpC,IACE,IAAI,CAACjF,OAAO,IACZiF,SAAS,KAAA,EAAuB,IAChC,IAAI,CAACxC,QAAQ,CAAA,EAAmB,CAAC,EACjC;MACA,IAAI,CAACpD,IAAI,CAAC6F,gBAAgB,CAAC,IAAI,CAAC3F,WAAW,EAAE,IAAI,CAAC4F,UAAU,CAAC,CAAC,CAAC;IACjE;EACF;EAEAC,aAAaA,CAACH,SAAiB,EAAE;IAE/B,IACE,IAAI,CAACjF,OAAO,IACZiF,SAAS,KAAA,EAAuB,IAChC,IAAI,CAACxC,QAAQ,CAAA,EAAmB,CAAC,EACjC;MACA,OAAO,IAAI;IACb;EACF;EAEAqC,kBAAkBA,CAAC3B,IAAY,EAAQ;IAErC,MAAMkC,qBAAqB,GAAG,IAAI,CAACnF,sBAAsB;IACzD,IAAI,CAACmF,qBAAqB,EAAE;IAS5B,IAAIlC,IAAI,KAAA,EAAoB,EAAE;MAE5B;IACF;IAGA,IAAIA,IAAI,KAAA,EAAuB,EAAE;MAC/B,IAAI,CAACjD,sBAAsB,GAAG,IAAI;MAClC;IACF;IAEA,IAAI,CAAC4B,SAAK,CAAA,EAAI,CAAC;IACf,IAAI,CAACtC,MAAM,CAAC,CAAC;IACb6F,qBAAqB,CAACC,OAAO,GAAG,IAAI;EACtC;EAEAX,cAAcA,CAACrC,GAAW,EAAQ;IAEhC,MAAM+C,qBAAqB,GAAG,IAAI,CAACnF,sBAAsB;IACzD,IAAI,CAACmF,qBAAqB,EAAE;IAS5B,MAAME,GAAG,GAAGjD,GAAG,CAAC1C,MAAM;IAEtB,IAAIyD,CAAC;IACL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,GAAG,IAAIjD,GAAG,CAAC5C,UAAU,CAAC2D,CAAC,CAAC,KAAA,EAAoB,EAAEA,CAAC,EAAE,EAAE;IACnE,IAAIA,CAAC,KAAKkC,GAAG,EAAE;MAEb;IACF;IAGA,MAAMC,GAAG,GAAGlD,GAAG,CAAC5C,UAAU,CAAC2D,CAAC,CAAC;IAC7B,IAAImC,GAAG,KAAA,EAAuB,EAAE;MAC9B,IAEEA,GAAG,KAAA,EAAoB,IAEvBnC,CAAC,GAAG,CAAC,KAAKkC,GAAG,EACb;QAEA,IAAI,CAACrF,sBAAsB,GAAG,IAAI;QAClC;MACF;MAEA,MAAMuF,OAAO,GAAGnD,GAAG,CAAC5C,UAAU,CAAC2D,CAAC,GAAG,CAAC,CAAC;MAErC,IAAIoC,OAAO,KAAA,EAAuB,EAAE;QAGlC,IAAI7G,kBAAkB,CAACkE,IAAI,CAACR,GAAG,CAACoD,KAAK,CAACrC,CAAC,GAAG,CAAC,EAAEkC,GAAG,GAAG,CAAC,CAAC,CAAC,EAAE;UAKtD;QACF;MAGF,CAAC,MAAM,IAAIE,OAAO,KAAA,EAAoB,EAAE;QAGtC,IAAI,CAACvF,sBAAsB,GAAG,IAAI;QAClC;MACF;IACF;IAEA,IAAI,CAAC4B,SAAK,CAAA,EAAI,CAAC;IACf,IAAI,CAACtC,MAAM,CAAC,CAAC;IACb6F,qBAAqB,CAACC,OAAO,GAAG,IAAI;EACtC;EAEAK,OAAOA,CAACC,IAAY,EAAE;IACpB,IAAI,CAAC,IAAI,CAACzG,MAAM,CAACmE,WAAW,EAAE;IAG9B,MAAMuC,KAAK,GAAGD,IAAI,GAAG,IAAI,CAACvG,IAAI,CAACyG,cAAc,CAAC,CAAC;IAE/C,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,KAAK,EAAExC,CAAC,EAAE,EAAE;MAC9B,IAAI,CAACI,QAAQ,CAAC,CAAC;IACjB;EACF;EAEAK,QAAQA,CAACE,IAAqB,EAAEnC,GAAS,EAAE;IAAA,IAAA,SAAA;IACzC,IAAI,CAAC,IAAI,CAAC1C,MAAM,CAACmE,WAAW,EAAE;IAG9B,MAAMsC,IAAI,GAAG/D,GAAG,IAAA,IAAA,GAAA,KAAA,CAAA,GAAA,CAAA,SAAA,GAAHA,GAAG,CAAGmC,IAAI,CAAC,KAAA,IAAA,GAAA,KAAA,CAAA,GAAXnC,SAAAA,CAAa+D,IAAI;IAC9B,IAAIA,IAAI,IAAI,IAAI,EAAE;MAChB,MAAMC,KAAK,GAAGD,IAAI,GAAG,IAAI,CAACvG,IAAI,CAACyG,cAAc,CAAC,CAAC;MAE/C,KAAK,IAAIzC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwC,KAAK,EAAExC,CAAC,EAAE,EAAE;QAC9B,IAAI,CAACI,QAAQ,CAAC,CAAC;MACjB;IACF;EACF;EAMA0B,UAAUA,CAAAA,EAAW;IACnB,OAAO,IAAI,CAACxF,aAAa,GAAG,IAAI,CAACK,OAAO;EAC1C;EAEA+F,mBAAmBA,CAACtE,IAAY,EAAEuE,MAAc,EAAEC,OAAgB,EAAE;IAgBlE,IAAIA,OAAO,EAAE;MACX,IAAI,CAAC9F,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACW,KAAK,CAACW,IAAI,EAAEuE,MAAM,CAAC;IAC1B,CAAC,MAAM;MACL,MAAME,eAAe,GAAG;QACtBZ,OAAO,EAAE;MACX,CAAC;MACD,IAAI,CAACpF,sBAAsB,GAAGgG,eAAe;MAC7C,IAAI,CAACpF,KAAK,CAACW,IAAI,EAAEuE,MAAM,CAAC;MAIxB,IAAIE,eAAe,CAACZ,OAAO,EAAE;QAC3B,IAAI,CAACnE,MAAM,CAAC,CAAC;QACb,IAAI,CAACiC,OAAO,CAAC,CAAC;QACd,IAAI,CAACtB,SAAK,CAAA,EAAI,CAAC;MACjB;IACF;EACF;EAEAhB,KAAKA,CACHW,IAAmB,EACnBuE,MAAe,EACfzD,qBAA+B,EAG/B4D,0BAAmC,EACnCC,WAAqB,EACrB;IAAA,IAAA,WAAA;IACA,IAAI,CAAC3E,IAAI,EAAE;IAEX,IAAI,CAACf,iBAAiB,GAAG,KAAK;IAE9B,MAAM2F,QAAQ,GAAG5E,IAAI,CAAC6E,IAAI;IAC1B,MAAMnH,MAAM,GAAG,IAAI,CAACA,MAAM;IAE1B,MAAMoH,UAAU,GAAGpH,MAAM,CAAC+B,OAAO;IACjC,IAEEO,IAAI,CAAC+E,QAAQ,EACb;MACArH,MAAM,CAAC+B,OAAO,GAAG,IAAI;IACvB;IAEA,MAAMuF,WAAW,GACf,IAAI,CACFJ,QAAQ,CAOT;IACH,IAAII,WAAW,KAAKC,SAAS,EAAE;MAC7B,MAAM,IAAIC,cAAc,CACrB,wBAAuBC,IAAI,CAACC,SAAS,CACpCR,QACF,CAAE,qBAAoBO,IAAI,CAACC,SAAS,CAACpF,IAAI,CAACvC,WAAW,CAAC4H,IAAI,CAAE,EAC9D,CAAC;IACH;IAEA,IAAI,CAAC/G,WAAW,CAACgH,IAAI,CAACtF,IAAI,CAAC;IAE3B,MAAMuF,QAAQ,GAAG,IAAI,CAAC/G,UAAU;IAChC,IAAI,CAACA,UAAU,GAAGwB,IAAI,CAACI,GAAG,IAAI6E,SAAS;IACvC,IAAI,CAAC3F,mBAAmB,CAAC,IAAI,CAACd,UAAU,IAAI,CAAC+G,QAAQ,CAAC;IAEtD,MAAMC,iBAAiB,GACrBb,WAAW,IACVjH,MAAM,CAAC+H,oBAAoB,IAC1Bb,QAAQ,KAAK,oBAAoB,KAAA,CAAA,WAAA,GACjC5E,IAAI,CAAC0F,KAAK,KAAA,IAAA,GAAA,KAAA,CAAA,GAAV1F,WAAAA,CAAY2F,aAAa,CAAC,IAC5BrI,WAAW,CAAC0C,IAAI,EAAEuE,MAAM,EAAE,IAAI,CAACjG,WAAW,CAAC;IAE7C,IAAIkH,iBAAiB,EAAE;MACrB,IAAI,CAACnF,SAAK,CAAA,EAAI,CAAC;MACf,IAAI,CAACpB,iBAAiB,GAAG,KAAK;IAChC;IAEA,IAAI,CAACD,gBAAgB,GAAG,CAAC;IAEzB,IAAI,CAAC4G,qBAAqB,CAAC5F,IAAI,EAAEuE,MAAM,CAAC;IAExC,MAAMnE,GAAG,GAAGwE,QAAQ,KAAK,SAAS,IAAIA,QAAQ,KAAK,MAAM,GAAG,IAAI,GAAG5E,IAAI,CAACI,GAAG;IAE3E,IAAI,CAAC+B,WAAW,CAAC/B,GAAG,EAAE4E,WAAW,CAACa,IAAI,CAAC,IAAI,EAAE7F,IAAI,EAAEuE,MAAM,CAAC,CAAC;IAE3D,IAAIiB,iBAAiB,EAAE;MACrB,IAAI,CAACM,sBAAsB,CAAC9F,IAAI,EAAEuE,MAAM,CAAC;MACzC,IAAI,CAAClE,SAAK,CAAA,EAAI,CAAC;MACf,IAAI,CAAC3B,iBAAiB,GAAGoC,qBAAqB;IAChD,CAAC,MAAM,IAAIA,qBAAqB,IAAI,CAAC,IAAI,CAACpC,iBAAiB,EAAE;MAC3D,IAAI,CAACA,iBAAiB,GAAG,IAAI;MAC7B,IAAI,CAACoH,sBAAsB,CAAC9F,IAAI,EAAEuE,MAAM,CAAC;IAC3C,CAAC,MAAM;MACL,IAAI,CAACuB,sBAAsB,CAAC9F,IAAI,EAAEuE,MAAM,EAAEG,0BAA0B,CAAC;IACvE;IAGA,IAAI,CAACpG,WAAW,CAACyH,GAAG,CAAC,CAAC;IAEtBrI,MAAM,CAAC+B,OAAO,GAAGqF,UAAU;IAC3B,IAAI,CAACtG,UAAU,GAAG+G,QAAQ;IAE1B,IAAI,CAACtG,iBAAiB,GAAG,KAAK;EAChC;EAEAK,mBAAmBA,CAAC0G,uBAAiC,EAAE;IACrD,IAAIA,uBAAuB,EAAE,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC1D,IAAI,CAAC,IAAI,CAACzH,UAAU,EAAE,IAAI,CAAC0H,qBAAqB,CAAC,CAAC;EACpD;EAEAD,sBAAsBA,CAAAA,EAAG;IACvB,IAAI,IAAI,CAACtH,4BAA4B,EAAE;IACvC,IAAI,CAACA,4BAA4B,GAAG,IAAI;IAExC,MAAMwH,OAAO,GAAG,IAAI,CAACzI,MAAM,CAAC0I,sBAAsB;IAClD,IAAID,OAAO,EAAE;MACX,IAAI,CAACE,aAAa,CAChB;QACExB,IAAI,EAAE,cAAc;QACpByB,KAAK,EAAEH;MACT,CAAC,EAAA,CAEH,CAAC;IACH;EACF;EAEAD,qBAAqBA,CAAAA,EAAG;IACtB,IAAI,CAAC,IAAI,CAACvH,4BAA4B,EAAE;IACxC,IAAI,CAACA,4BAA4B,GAAG,KAAK;IAEzC,MAAMwH,OAAO,GAAG,IAAI,CAACzI,MAAM,CAAC6I,qBAAqB;IACjD,IAAIJ,OAAO,EAAE;MACX,IAAI,CAACE,aAAa,CAChB;QACExB,IAAI,EAAE,cAAc;QACpByB,KAAK,EAAEH;MACT,CAAC,EAAA,CAEH,CAAC;IACH;EACF;EAEAK,cAAcA,CACZxG,IAMa,EACO;IACpB,MAAM0F,KAAK,GAAG1F,IAAI,CAAC0F,KAAK;IACxB,IACEA,KAAK,IACLA,KAAK,CAACe,GAAG,IAAI,IAAI,IACjBf,KAAK,CAACgB,QAAQ,IAAI,IAAI,IACtB1G,IAAI,CAACsG,KAAK,KAAKZ,KAAK,CAACgB,QAAQ,EAC7B;MAEA,OAAOhB,KAAK,CAACe,GAAG;IAClB;EACF;EAEAE,SAASA,CACPC,KAAuC,EACvCrC,MAAc,EACdsC,IAAsB,GAAG,CAAC,CAAC,EAC3B;IACA,IAAI,EAACD,KAAK,IAAA,IAAA,IAALA,KAAK,CAAEzI,MAAM,CAAA,EAAE;IAEpB,IAAI;MAAEJ;IAAO,CAAC,GAAG8I,IAAI;IAErB,IAAI9I,MAAM,IAAI,IAAI,IAAI,IAAI,CAACL,MAAM,CAACmE,WAAW,EAAE;MAAA,IAAA,YAAA;MAC7C,MAAMiF,SAAS,GAAA,CAAA,YAAA,GAAGF,KAAK,CAAC,CAAC,CAAC,CAACxG,GAAG,KAAA,IAAA,GAAA,KAAA,CAAA,GAAZwG,YAAAA,CAAcG,KAAK,CAAC5C,IAAI;MAC1C,IAAI2C,SAAS,IAAI,IAAI,IAAIA,SAAS,KAAK,IAAI,CAAClJ,IAAI,CAACyG,cAAc,CAAC,CAAC,EAAE;QACjEtG,MAAM,GAAG,IAAI;MACf;IACF;IAEA,IAAIA,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC,CAAC;IAEzB,MAAMiJ,WAA+B,GAAG;MACtCC,WAAW,EAAEJ,IAAI,CAACI,WAAW;MAC7BC,iBAAiB,EAAE;IACrB,CAAC;IAED,MAAMC,SAAS,GAAGN,IAAI,CAACM,SAAS,GAAGN,IAAI,CAACM,SAAS,CAACtB,IAAI,CAAC,IAAI,CAAC,GAAG,IAAI;IAEnE,MAAM/B,GAAG,GAAG8C,KAAK,CAACzI,MAAM;IACxB,KAAK,IAAIyD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,GAAG,EAAElC,CAAC,EAAE,EAAE;MAC5B,MAAM5B,IAAI,GAAG4G,KAAK,CAAChF,CAAC,CAAC;MACrB,IAAI,CAAC5B,IAAI,EAAE;MAEX,IAAI6G,IAAI,CAACO,SAAS,EAAE,IAAI,CAACC,aAAa,CAACzF,CAAC,KAAK,CAAC,EAAEoF,WAAW,CAAC;MAE5D,IAAI,CAAC3H,KAAK,CAACW,IAAI,EAAEuE,MAAM,EAAEU,SAAS,EAAE4B,IAAI,CAACnC,0BAA0B,IAAI,CAAC,CAAC;MAEzEmC,IAAI,CAACS,QAAQ,IAAA,IAAA,GAAA,KAAA,CAAA,GAAbT,IAAI,CAACS,QAAQ,CAAGtH,IAAI,EAAE4B,CAAC,CAAC;MAExB,IAAIA,CAAC,GAAGkC,GAAG,GAAG,CAAC,EAAEqD,SAAS,IAAA,IAAA,GAAA,KAAA,CAAA,GAATA,SAAS,CAAG,CAAC;MAE9B,IAAIN,IAAI,CAACO,SAAS,EAAE;QAClB,IAAIxF,CAAC,GAAG,CAAC,KAAKkC,GAAG,EAAE;UACjB,IAAI,CAACnC,OAAO,CAAC,CAAC,CAAC;QACjB,CAAC,MAAM;UAAA,IAAA,aAAA;UACL,MAAM4F,QAAQ,GAAGX,KAAK,CAAChF,CAAC,GAAG,CAAC,CAAC;UAC7BoF,WAAW,CAACE,iBAAiB,GAAG,CAAA,CAAA,aAAA,GAAA,QAAQ,CAAC9G,GAAG,KAAA,IAAA,GAAA,KAAA,CAAA,GAAZ,aAAA,CAAc2G,KAAK,CAAC5C,IAAI,KAAI,CAAC;UAE7D,IAAI,CAACkD,aAAa,CAAC,IAAI,EAAEL,WAAW,CAAC;QACvC;MACF;IACF;IAEA,IAAIjJ,MAAM,EAAE,IAAI,CAAC2B,MAAM,CAAC,CAAC;EAC3B;EAEA8H,wBAAwBA,CAACxH,IAAY,EAAEuE,MAAc,EAAE;IACrD,MAAMxG,MAAM,GAAGiC,IAAI,CAACyH,eAAe,IAAIzH,IAAI,CAACyH,eAAe,CAACtJ,MAAM,GAAG,CAAC;IACtE,IAAIJ,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC,CAAC;IACzB,IAAI,CAACsB,KAAK,CAACW,IAAI,EAAEuE,MAAM,CAAC;IACxB,IAAIxG,MAAM,EAAE,IAAI,CAAC2B,MAAM,CAAC,CAAC;EAC3B;EAEAgI,UAAUA,CAACnD,MAA8C,EAAE;IACzD,MAAMvE,IAAI,GAAGuE,MAAM,CAACoD,IAAI;IAExB,IAAI3H,IAAI,CAAC6E,IAAI,KAAK,gBAAgB,EAAE;MAClC,IAAI,CAACtE,KAAK,CAAC,CAAC;IACd;IAEA,IAAI,CAAClB,KAAK,CAACW,IAAI,EAAEuE,MAAM,CAAC;EAC1B;EAEAuB,sBAAsBA,CAAC9F,IAAY,EAAEuE,MAAe,EAAE/B,UAAmB,EAAE;IACzE,MAAM;MAAEoF,aAAa;MAAEC;IAAiB,CAAC,GAAG7H,IAAI;IAIhD,IAAI4H,aAAa,IAAA,IAAA,IAAbA,aAAa,CAAEzJ,MAAM,EAAE;MACzB,IAAI,CAAC2J,cAAc,CAAA,CAAA,EAEjBF,aAAa,EACb5H,IAAI,EACJuE,MAAM,EACN/B,UACF,CAAC;IACH;IACA,IAAIqF,gBAAgB,IAAA,IAAA,IAAhBA,gBAAgB,CAAE1J,MAAM,EAAE;MAC5B,IAAI,CAAC2J,cAAc,CAAA,CAAA,EAEjBD,gBAAgB,EAChB7H,IAAI,EACJuE,MAAM,EACN/B,UACF,CAAC;IACH;EACF;EAEAoD,qBAAqBA,CAAC5F,IAAY,EAAEuE,MAAc,EAAE;IAClD,MAAMwD,QAAQ,GAAG/H,IAAI,CAACyH,eAAe;IACrC,IAAI,EAACM,QAAQ,IAAA,IAAA,IAARA,QAAQ,CAAE5J,MAAM,CAAA,EAAE;IACvB,IAAI,CAAC2J,cAAc,CAAA,CAAA,EAAuBC,QAAQ,EAAE/H,IAAI,EAAEuE,MAAM,CAAC;EACnE;EAEAxD,wBAAwBA,CAAAA,EAAG;IACzB,IAAI,IAAI,CAAC9B,iBAAiB,EAAE,IAAI,CAAC+I,kBAAkB,CAAC,CAAC;IACrD,IAAI,CAAC/I,iBAAiB,GAAG,IAAI;IAC7B,IAAI,CAACC,oBAAoB,GAAG,IAAI;EAClC;EAEA8I,kBAAkBA,CAAAA,EAAG;IACnB,MAAMhI,IAAI,GAAG,IAAI,CAAC1B,WAAW,CAAC,IAAI,CAACA,WAAW,CAACH,MAAM,GAAG,CAAC,CAAC;IAC1D,MAAM4J,QAAQ,GAAG/H,IAAI,CAAC4H,aAAa;IACnC,IAAI,EAACG,QAAQ,IAAA,IAAA,IAARA,QAAQ,CAAE5J,MAAM,CAAA,EAAE;IAEvB,MAAM8J,QAAQ,GAAG,IAAI,CAACjH,QAAQ,CAAA,EAAgB,CAAC;IAC/C,MAAMjD,MAAM,GAAG,IAAI,CAACmB,oBAAoB;IACxC,MAAMgJ,oBAAoB,GAAG,IAAI,CAACtJ,gBAAgB,CAACuJ,IAAI;IACvD,IAAIpK,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC,CAAC;IACzB,IAAI,CAAC+J,cAAc,CAAA,CAAA,EAAqBC,QAAQ,EAAE/H,IAAI,CAAC;IACvD,IAAIiI,QAAQ,IAAIC,oBAAoB,KAAK,IAAI,CAACtJ,gBAAgB,CAACuJ,IAAI,EAAE;MACnE,IAAI,CAAC5H,KAAK,CAAC,CAAC;IACd;IACA,IAAIxC,MAAM,EAAE,IAAI,CAAC2B,MAAM,CAAC,CAAC;EAC3B;EAEA0I,yBAAyBA,CAAAA,EAAG;IAC1B,IAAI,CAAClJ,oBAAoB,GAAG,KAAK;EACnC;EAEAmJ,aAAaA,CACXzB,KAAe,EACfrC,MAAc,EACdsC,IAA0B,GAAG,CAAC,CAAC,EAC/B;IAAA,IAAA,YAAA;IACAA,IAAI,CAACO,SAAS,GAAG,IAAI;IACrB,CAAA,YAAA,GAAA,IAAI,CAACrJ,MAAM,KAAA,IAAA,GAAA,YAAA,GAAX,IAAI,CAACA,MAAM,GAAK,KAAK;IACrB,IAAI,CAAC4I,SAAS,CAACC,KAAK,EAAErC,MAAM,EAAEsC,IAAI,CAAC;EACrC;EAEAyB,SAASA,CAACC,KAAe,EAAEhE,MAAc,EAAEsC,IAAsB,GAAG,CAAC,CAAC,EAAE;IACtE,IAAIA,IAAI,CAACM,SAAS,IAAI,IAAI,EAAE;MAC1BN,IAAI,CAACM,SAAS,GAAGqB,cAAc;IACjC;IAEA,IAAI,CAAC7B,SAAS,CAAC4B,KAAK,EAAEhE,MAAM,EAAEsC,IAAI,CAAC;EACrC;EAEAQ,aAAaA,CAACoB,OAAgB,EAAE5B,IAAwB,EAAE;IACxD,MAAMnJ,MAAM,GAAG,IAAI,CAACA,MAAM;IAG1B,IAAIA,MAAM,CAACmE,WAAW,IAAInE,MAAM,CAAC8B,OAAO,EAAE;IAI1C,IAAI9B,MAAM,CAAC+B,OAAO,EAAE;MAClB,IAAI,CAACc,KAAK,CAAC,CAAC;MACZ;IACF;IAEA,IAAI,CAACkI,OAAO,EAAE;MACZ;IACF;IAEA,MAAM3B,SAAS,GAAGD,IAAI,CAACK,iBAAiB;IACxC,MAAMwB,eAAe,GAAG,IAAI,CAAC1J,gBAAgB;IAC7C,IAAI8H,SAAS,GAAG,CAAC,IAAI4B,eAAe,GAAG,CAAC,EAAE;MACxC,MAAMC,MAAM,GAAG7B,SAAS,GAAG4B,eAAe;MAC1C,IAAIC,MAAM,IAAI,CAAC,EAAE;QACf,IAAI,CAAChH,OAAO,CAACgH,MAAM,IAAI,CAAC,CAAC;QACzB;MACF;IACF;IAGA,IAAI,IAAI,CAAC/K,IAAI,CAAC6C,UAAU,CAAC,CAAC,EAAE;MAa1B,IAAI,CAACkB,OAAO,CAAC,CAAC,CAAC;IACjB;EACF;EAOAiH,mBAAmBA,CAACzC,OAAkB,EAAsB;IAG1D,IAAIA,OAAO,CAAC0C,MAAM,EAAE,OAAA,CAAA;IAEpB,IAAI,IAAI,CAACjK,gBAAgB,CAACkK,GAAG,CAAC3C,OAAO,CAAC,EAAE,OAAA,CAAA;IAExC,IACE,IAAI,CAACzH,iBAAiB,KACrBtB,WAAW,CAACiE,IAAI,CAAC8E,OAAO,CAACG,KAAK,CAAC,IAC9BjJ,qBAAqB,CAACgE,IAAI,CAAC8E,OAAO,CAACG,KAAK,CAAC,CAAC,EAC5C;MACA,OAAA,CAAA;IACF;IAEA,IAAI,CAAC1H,gBAAgB,CAACmK,GAAG,CAAC5C,OAAO,CAAC;IAElC,IAAI,CAAC,IAAI,CAACzI,MAAM,CAACsL,kBAAkB,CAAC7C,OAAO,CAACG,KAAK,CAAC,EAAE;MAClD,OAAA,CAAA;IACF;IAEA,OAAA,CAAA;EACF;EAEAD,aAAaA,CAACF,OAAkB,EAAE8C,YAAkC,EAAE;IACpE,MAAMC,gBAAgB,GAAG,IAAI,CAACxK,iBAAiB;IAC/C,MAAMyK,cAAc,GAAGhD,OAAO,CAACtB,IAAI,KAAK,cAAc;IAItD,MAAMuE,aAAa,GACjBD,cAAc,IACdF,YAAY,KAAA,CAA6B,IACzC,CAAC,IAAI,CAACvK,iBAAiB;IAEzB,IACE0K,aAAa,IACb,IAAI,CAACxL,IAAI,CAAC6C,UAAU,CAAC,CAAC,IACtBwI,YAAY,KAAA,CAAiC,EAC7C;MACA,IAAI,CAACtH,OAAO,CAAC,CAAC,CAAC;IACjB;IAEA,MAAM0H,YAAY,GAAG,IAAI,CAAC1I,WAAW,CAAC,CAAC;IACvC,IACE0I,YAAY,KAAA,EAAgC,IAC5CA,YAAY,KAAA,GAA6B,EACzC;MACA,IAAI,CAAC9I,KAAK,CAAC,CAAC;IACd;IAEA,IAAI+I,GAAG;IACP,IAAIH,cAAc,EAAE;MAClBG,GAAG,GAAI,KAAInD,OAAO,CAACG,KAAM,IAAG;MAC5B,IAAI,IAAI,CAAC5I,MAAM,CAACK,MAAM,CAACwL,sBAAsB,EAAE;QAAA,IAAA,YAAA;QAC7C,MAAMZ,MAAM,GAAA,CAAA,YAAA,GAAGxC,OAAO,CAAC/F,GAAG,KAAA,IAAA,GAAA,KAAA,CAAA,GAAX+F,YAAAA,CAAaY,KAAK,CAACyC,MAAM;QACxC,IAAIb,MAAM,EAAE;UACV,MAAMc,YAAY,GAAG,IAAIC,MAAM,CAAC,WAAW,GAAGf,MAAM,GAAG,GAAG,EAAE,GAAG,CAAC;UAChEW,GAAG,GAAGA,GAAG,CAACK,OAAO,CAACF,YAAY,EAAE,IAAI,CAAC;QACvC;QAEA,IAAIG,UAAU,GAAG,IAAI,CAAClM,MAAM,CAACmE,WAAW,GACpC,CAAC,GACD,IAAI,CAACjE,IAAI,CAACiM,gBAAgB,CAAC,CAAC;QAEhC,IAAI,IAAI,CAAClG,aAAa,CAAA,EAAgB,CAAC,IAAI,IAAI,CAACjG,MAAM,CAACmE,WAAW,EAAE;UAClE+H,UAAU,IAAI,IAAI,CAAClG,UAAU,CAAC,CAAC;QACjC;QAEA4F,GAAG,GAAGA,GAAG,CAACK,OAAO,CAAC,UAAU,EAAG,KAAI,GAAG,CAACG,MAAM,CAACF,UAAU,CAAE,EAAC,CAAC;MAC9D;IACF,CAAC,MAAM,IAAI,CAACV,gBAAgB,EAAE;MAC5BI,GAAG,GAAI,KAAInD,OAAO,CAACG,KAAM,EAAC;IAC5B,CAAC,MAAM;MAILgD,GAAG,GAAI,KAAInD,OAAO,CAACG,KAAM,IAAG;IAC9B;IAGA,IAAI,IAAI,CAACtF,QAAQ,CAAA,EAAgB,CAAC,EAAE,IAAI,CAACR,MAAM,CAAC,CAAC;IAEjD,IAAI,CAAC8B,MAAM,CAAC,OAAO,EAAE6D,OAAO,CAAC/F,GAAG,CAAC;IACjC,IAAI,CAACa,OAAO,CAACqI,GAAG,EAAEH,cAAc,CAAC;IAEjC,IAAI,CAACA,cAAc,IAAI,CAACD,gBAAgB,EAAE;MACxC,IAAI,CAACvH,OAAO,CAAC,CAAC,EAAE,IAAI,CAAC;IACvB;IAEA,IAAIyH,aAAa,IAAIH,YAAY,KAAA,CAAkC,EAAE;MACnE,IAAI,CAACtH,OAAO,CAAC,CAAC,CAAC;IACjB;EACF;EAEAmG,cAAcA,CACZjD,IAAkB,EAClBkD,QAA8B,EAC9B/H,IAAY,EACZuE,MAAe,EACf/B,UAAkB,GAAG,CAAC,EACtB;IACA,MAAMuH,OAAO,GAAG/J,IAAI,CAACI,GAAG;IACxB,MAAM0D,GAAG,GAAGiE,QAAQ,CAAC5J,MAAM;IAC3B,IAAI6L,MAAM,GAAG,CAAC,CAACD,OAAO;IACtB,MAAME,aAAa,GAAGD,MAAM,GAAGD,OAAO,CAAChD,KAAK,CAAC5C,IAAI,GAAG,CAAC;IACrD,MAAM+F,WAAW,GAAGF,MAAM,GAAGD,OAAO,CAACI,GAAG,CAAChG,IAAI,GAAG,CAAC;IACjD,IAAIiG,QAAQ,GAAG,CAAC;IAChB,IAAIC,qBAAqB,GAAG,CAAC;IAE7B,MAAM/I,YAAY,GAAG,IAAI,CAAC5C,iBAAiB,GACvC,YAAY,CAAC,CAAC,GACd,IAAI,CAACiD,OAAO,CAACkE,IAAI,CAAC,IAAI,CAAC;IAE3B,KAAK,IAAIjE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkC,GAAG,EAAElC,CAAC,EAAE,EAAE;MAC5B,MAAMuE,OAAO,GAAG4B,QAAQ,CAACnG,CAAC,CAAC;MAE3B,MAAM0I,WAAW,GAAG,IAAI,CAAC1B,mBAAmB,CAACzC,OAAO,CAAC;MACrD,IAAImE,WAAW,KAAA,CAA6B,EAAE;QAC5CN,MAAM,GAAG,KAAK;QACd;MACF;MACA,IAAIA,MAAM,IAAI7D,OAAO,CAAC/F,GAAG,IAAIkK,WAAW,KAAA,CAA6B,EAAE;QACrE,MAAMC,gBAAgB,GAAGpE,OAAO,CAAC/F,GAAG,CAAC2G,KAAK,CAAC5C,IAAI;QAC/C,MAAMqG,cAAc,GAAGrE,OAAO,CAAC/F,GAAG,CAAC+J,GAAG,CAAChG,IAAI;QAC3C,IAAIU,IAAI,KAAA,CAAyB,EAAE;UACjC,IAAI8D,MAAM,GAAG,CAAC;UACd,IAAI/G,CAAC,KAAK,CAAC,EAAE;YAGX,IACE,IAAI,CAAChE,IAAI,CAAC6C,UAAU,CAAC,CAAC,KACrB0F,OAAO,CAACtB,IAAI,KAAK,aAAa,IAC7B0F,gBAAgB,IAAIC,cAAc,CAAC,EACrC;cACA7B,MAAM,GAAG0B,qBAAqB,GAAG,CAAC;YACpC;UACF,CAAC,MAAM;YACL1B,MAAM,GAAG4B,gBAAgB,GAAGH,QAAQ;UACtC;UACAA,QAAQ,GAAGI,cAAc;UAEzBlJ,YAAY,CAACqH,MAAM,CAAC;UACpB,IAAI,CAACtC,aAAa,CAACF,OAAO,EAAA,CAA0B,CAAC;UAErD,IAAIvE,CAAC,GAAG,CAAC,KAAKkC,GAAG,EAAE;YACjBxC,YAAY,CACVmJ,IAAI,CAACC,GAAG,CAACT,aAAa,GAAGG,QAAQ,EAAEC,qBAAqB,CAC1D,CAAC;YACDD,QAAQ,GAAGH,aAAa;UAC1B;QACF,CAAC,MAAM,IAAIpF,IAAI,KAAA,CAAuB,EAAE;UACtC,MAAM8D,MAAM,GACV4B,gBAAgB,IAAI3I,CAAC,KAAK,CAAC,GAAGqI,aAAa,GAAGG,QAAQ,CAAC;UACzDA,QAAQ,GAAGI,cAAc;UAEzBlJ,YAAY,CAACqH,MAAM,CAAC;UACpB,IAAI,CAACtC,aAAa,CAACF,OAAO,EAAA,CAA0B,CAAC;UAErD,IAAIvE,CAAC,GAAG,CAAC,KAAKkC,GAAG,EAAE;YACjBxC,YAAY,CAACmJ,IAAI,CAACE,GAAG,CAAC,CAAC,EAAET,WAAW,GAAGE,QAAQ,CAAC,CAAC;YACjDA,QAAQ,GAAGF,WAAW;UACxB;QACF,CAAC,MAAM;UACL,MAAMvB,MAAM,GACV4B,gBAAgB,IAAI3I,CAAC,KAAK,CAAC,GAAGsI,WAAW,GAAG1H,UAAU,GAAG4H,QAAQ,CAAC;UACpEA,QAAQ,GAAGI,cAAc;UAEzBlJ,YAAY,CAACqH,MAAM,CAAC;UACpB,IAAI,CAACtC,aAAa,CAACF,OAAO,EAAA,CAA0B,CAAC;QACvD;MACF,CAAC,MAAM;QACL6D,MAAM,GAAG,KAAK;QACd,IAAIM,WAAW,KAAA,CAA6B,EAAE;UAC5C;QACF;QAEA,IAAIxG,GAAG,KAAK,CAAC,EAAE;UACb,MAAM8G,UAAU,GAAGzE,OAAO,CAAC/F,GAAG,GAC1B+F,OAAO,CAAC/F,GAAG,CAAC2G,KAAK,CAAC5C,IAAI,KAAKgC,OAAO,CAAC/F,GAAG,CAAC+J,GAAG,CAAChG,IAAI,GAC/C,CAAC/G,WAAW,CAACiE,IAAI,CAAC8E,OAAO,CAACG,KAAK,CAAC;UAEpC,MAAMuE,iBAAiB,GACrBD,UAAU,IACV,CAAChO,WAAW,CAACoD,IAAI,CAAC,IAClB,CAACnD,WAAW,CAAC0H,MAAM,CAAC,IACpB,CAACzH,iBAAiB,CAACyH,MAAM,CAAC,IAC1B,CAACxH,mBAAmB,CAACwH,MAAM,CAAC;UAE9B,IAAIM,IAAI,KAAA,CAAyB,EAAE;YACjC,IAAI,CAACwB,aAAa,CAChBF,OAAO,EACN0E,iBAAiB,IAAI7K,IAAI,CAAC6E,IAAI,KAAK,kBAAkB,IACnD+F,UAAU,IAAIjO,UAAU,CAAC4H,MAAM,EAAE;cAAEoD,IAAI,EAAE3H;YAAK,CAAC,CAAE,GAAA,CAAA,GAAA,CAGtD,CAAC;UACH,CAAC,MAAM,IAAI6K,iBAAiB,IAAIhG,IAAI,KAAA,CAA0B,EAAE;YAC9D,IAAI,CAACwB,aAAa,CAACF,OAAO,EAAA,CAA0B,CAAC;UACvD,CAAC,MAAM;YACL,IAAI,CAACE,aAAa,CAACF,OAAO,EAAA,CAA8B,CAAC;UAC3D;QACF,CAAC,MAAM,IACLtB,IAAI,KAAA,CAAuB,IAC3B,EAAE7E,IAAI,CAAC6E,IAAI,KAAK,kBAAkB,IAAI7E,IAAI,CAAC8K,UAAU,CAAC3M,MAAM,GAAG,CAAC,CAAC,IACjE6B,IAAI,CAAC6E,IAAI,KAAK,WAAW,IACzB7E,IAAI,CAAC6E,IAAI,KAAK,iBAAiB,EAC/B;UAMA,IAAI,CAACwB,aAAa,CAChBF,OAAO,EACPvE,CAAC,KAAK,CAAC,GAAA,CAAA,GAEHA,CAAC,KAAKkC,GAAG,GAAG,CAAC,GAAA,CAAA,GAAA,CAGnB,CAAC;QACH,CAAC,MAAM;UACL,IAAI,CAACuC,aAAa,CAACF,OAAO,EAAA,CAA8B,CAAC;QAC3D;MACF;IACF;IAEA,IAAItB,IAAI,KAAA,CAA0B,IAAImF,MAAM,IAAII,QAAQ,EAAE;MACxD,IAAI,CAACpL,gBAAgB,GAAGoL,QAAQ;IAClC;EACF;AACF;AAGAW,MAAM,CAACC,MAAM,CAACxN,OAAO,CAACyN,SAAS,EAAEC,kBAAkB,CAAC;AAEjB;EAEjC1N,OAAO,CAACyN,SAAS,CAACE,IAAI,GAAG,SAASA,IAAIA,CAAAA,EAAgB,CAAC,CAAC;AAC1D;AAAC,IAAA,QAAA,GAIc3N,OAAO4N;AAAAA,OAAAA,CAAAA,OAAAA,GAAAA,QAAAA;AAEtB,SAAS5C,cAAcA,CAAAA,EAAgB;EACrC,IAAI,CAACnI,SAAK,CAAA,EAAI,CAAC;EACf,IAAI,CAACE,KAAK,CAAC,CAAC;AACd","sourcesContent":["import Buffer, { type Pos } from \"./buffer\";\nimport type { Loc } from \"./buffer\";\nimport * as n from \"./node\";\nimport type * as t from \"@babel/types\";\nimport {\n  isFunction,\n  isStatement,\n  isClassBody,\n  isTSInterfaceBody,\n  isTSEnumDeclaration,\n} from \"@babel/types\";\nimport type {\n  RecordAndTuplePluginOptions,\n  PipelineOperatorPluginOptions,\n} from \"@babel/parser\";\nimport type { Opts as jsescOptions } from \"jsesc\";\n\nimport * as generatorFunctions from \"./generators\";\nimport type SourceMap from \"./source-map\";\nimport * as charCodes from \"charcodes\";\nimport type { TraceMap } from \"@jridgewell/trace-mapping\";\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst HAS_NEWLINE = /[\\n\\r\\u2028\\u2029]/;\nconst HAS_BlOCK_COMMENT_END = /\\*\\//;\n\nconst { needsParens } = n;\n\nconst enum COMMENT_TYPE {\n  LEADING,\n  INNER,\n  TRAILING,\n}\n\nconst enum COMMENT_SKIP_NEWLINE {\n  DEFAULT,\n  ALL,\n  LEADING,\n  TRAILING,\n}\n\nconst enum PRINT_COMMENT_HINT {\n  SKIP,\n  ALLOW,\n  DEFER,\n}\n\nexport type Format = {\n  shouldPrintComment: (comment: string) => boolean;\n  retainLines: boolean;\n  retainFunctionParens: boolean;\n  comments: boolean;\n  auxiliaryCommentBefore: string;\n  auxiliaryCommentAfter: string;\n  compact: boolean | \"auto\";\n  minified: boolean;\n  concise: boolean;\n  indent: {\n    adjustMultilineComment: boolean;\n    style: string;\n  };\n  recordAndTupleSyntaxType: RecordAndTuplePluginOptions[\"syntaxType\"];\n  jsescOption: jsescOptions;\n  /**\n   * @deprecated Removed in Babel 8, use `jsescOption` instead\n   */\n  jsonCompatibleStrings?: boolean;\n  /**\n   * For use with the Hack-style pipe operator.\n   * Changes what token is used for pipe bodies topic references.\n   */\n  topicToken?: PipelineOperatorPluginOptions[\"topicToken\"];\n  /**\n   * @deprecated Removed in Babel 8\n   */\n  decoratorsBeforeExport?: boolean;\n  /**\n   * The import attributes syntax style:\n   * - \"with\"        : `import { a } from \"b\" with { type: \"json\" };`\n   * - \"assert\"      : `import { a } from \"b\" assert { type: \"json\" };`\n   * - \"with-legacy\" : `import { a } from \"b\" with type: \"json\";`\n   */\n  importAttributesKeyword?: \"with\" | \"assert\" | \"with-legacy\";\n};\n\ninterface AddNewlinesOptions {\n  addNewlines(leading: boolean, node: t.Node): number;\n  nextNodeStartLine: number;\n}\n\ninterface PrintSequenceOptions extends Partial<AddNewlinesOptions> {\n  statement?: boolean;\n  indent?: boolean;\n  trailingCommentsLineOffset?: number;\n}\n\ninterface PrintListOptions {\n  separator?: (this: Printer) => void;\n  iterator?: (node: t.Node, index: number) => void;\n  statement?: boolean;\n  indent?: boolean;\n}\n\nexport type PrintJoinOptions = PrintListOptions & PrintSequenceOptions;\nclass Printer {\n  constructor(format: Format, map: SourceMap) {\n    this.format = format;\n    this._buf = new Buffer(map);\n\n    this._indentChar = format.indent.style.charCodeAt(0);\n    this._indentRepeat = format.indent.style.length;\n\n    this._inputMap = map?._inputMap;\n  }\n  declare _inputMap: TraceMap;\n\n  declare format: Format;\n  inForStatementInitCounter: number = 0;\n\n  declare _buf: Buffer;\n  _printStack: Array<t.Node> = [];\n  _indent: number = 0;\n  _indentChar: number = 0;\n  _indentRepeat: number = 0;\n  _insideAux: boolean = false;\n  _parenPushNewlineState: { printed: boolean } | null = null;\n  _noLineTerminator: boolean = false;\n  _printAuxAfterOnNextUserNode: boolean = false;\n  _printedComments = new Set<t.Comment>();\n  _endsWithInteger = false;\n  _endsWithWord = false;\n  _lastCommentLine = 0;\n  _endsWithInnerRaw: boolean = false;\n  _indentInnerComments: boolean = true;\n\n  generate(ast: t.Node) {\n    this.print(ast);\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  /**\n   * Increment indent size.\n   */\n\n  indent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent++;\n  }\n\n  /**\n   * Decrement indent size.\n   */\n\n  dedent(): void {\n    if (this.format.compact || this.format.concise) return;\n\n    this._indent--;\n  }\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  semicolon(force: boolean = false): void {\n    this._maybeAddAuxComment();\n    if (force) {\n      this._appendChar(charCodes.semicolon);\n    } else {\n      this._queue(charCodes.semicolon);\n    }\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  rightBrace(node: t.Node): void {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.token(\"}\");\n  }\n\n  rightParens(node: t.Node): void {\n    this.sourceWithOffset(\"end\", node.loc, 0, -1);\n    this.token(\")\");\n  }\n\n  /**\n   * Add a space to the buffer unless it is compact.\n   */\n\n  space(force: boolean = false): void {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n      if (lastCp !== charCodes.space && lastCp !== charCodes.lineFeed) {\n        this._space();\n      }\n    }\n  }\n\n  /**\n   * Writes a token that can't be safely parsed without taking whitespace into account.\n   */\n\n  word(str: string, noLineTerminatorAfter: boolean = false): void {\n    this._maybePrintInnerComments();\n\n    // prevent concatenating words and creating // comment out of division and regex\n    if (\n      this._endsWithWord ||\n      (str.charCodeAt(0) === charCodes.slash && this.endsWith(charCodes.slash))\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, false);\n\n    this._endsWithWord = true;\n    this._noLineTerminator = noLineTerminatorAfter;\n  }\n\n  /**\n   * Writes a number token so that we can validate if it is an integer.\n   */\n\n  number(str: string): void {\n    this.word(str);\n\n    // Integer tokens need special handling because they cannot have '.'s inserted\n    // immediately after them.\n    this._endsWithInteger =\n      Number.isInteger(+str) &&\n      !NON_DECIMAL_LITERAL.test(str) &&\n      !SCIENTIFIC_NOTATION.test(str) &&\n      !ZERO_DECIMAL_INTEGER.test(str) &&\n      str.charCodeAt(str.length - 1) !== charCodes.dot;\n  }\n\n  /**\n   * Writes a simple token.\n   */\n  token(str: string, maybeNewline = false): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n    if (\n      (lastChar === charCodes.exclamationMark &&\n        // space is mandatory to avoid outputting <!--\n        // http://javascript.spec.whatwg.org/#comment-syntax\n        (str === \"--\" ||\n          // Needs spaces to avoid changing a! == 0 to a!== 0\n          strFirst === charCodes.equalsTo)) ||\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (strFirst === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (strFirst === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (strFirst === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._append(str, maybeNewline);\n    this._noLineTerminator = false;\n  }\n\n  tokenChar(char: number): void {\n    this._maybePrintInnerComments();\n\n    const lastChar = this.getLastChar();\n    if (\n      // Need spaces for operators of the same kind to avoid: `a+++b`\n      (char === charCodes.plusSign && lastChar === charCodes.plusSign) ||\n      (char === charCodes.dash && lastChar === charCodes.dash) ||\n      // Needs spaces to avoid changing '34' to '34.', which would still be a valid number.\n      (char === charCodes.dot && this._endsWithInteger)\n    ) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n    this._appendChar(char);\n    this._noLineTerminator = false;\n  }\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * This function checks the number of newlines in the queue and subtracts them.\n   * It currently has some limitations.\n   * @see {Buffer#getNewlineCount}\n   */\n  newline(i: number = 1, force?: boolean): void {\n    if (i <= 0) return;\n\n    if (!force) {\n      if (this.format.retainLines || this.format.compact) return;\n\n      if (this.format.concise) {\n        this.space();\n        return;\n      }\n    }\n\n    if (i > 2) i = 2; // Max two lines\n\n    i -= this._buf.getNewlineCount();\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n\n    return;\n  }\n\n  endsWith(char: number): boolean {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar(): number {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline(): number {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline(): void {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc: Loc | undefined, cb: () => void) {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop: \"start\" | \"end\", loc: Loc | undefined): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  sourceWithOffset(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    lineOffset: number,\n    columnOffset: number,\n  ): void {\n    if (!loc) return;\n\n    this._catchUp(prop, loc);\n\n    this._buf.sourceWithOffset(prop, loc, lineOffset, columnOffset);\n  }\n\n  withSource(\n    prop: \"start\" | \"end\",\n    loc: Loc | undefined,\n    cb: () => void,\n  ): void {\n    if (!loc) {\n      cb();\n      return;\n    }\n\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  sourceIdentifierName(identifierName: string, pos?: Pos): void {\n    if (!this._buf._canMarkIdName) return;\n\n    const sourcePosition = this._buf._sourcePosition;\n    sourcePosition.identifierNamePos = pos;\n    sourcePosition.identifierName = identifierName;\n  }\n\n  _space(): void {\n    this._queue(charCodes.space);\n  }\n\n  _newline(): void {\n    this._queue(charCodes.lineFeed);\n  }\n\n  _append(str: string, maybeNewline: boolean): void {\n    this._maybeAddParen(str);\n    this._maybeIndent(str.charCodeAt(0));\n\n    this._buf.append(str, maybeNewline);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _appendChar(char: number): void {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.appendChar(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _queue(char: number) {\n    this._maybeAddParenChar(char);\n    this._maybeIndent(char);\n\n    this._buf.queue(char);\n\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(firstChar: number): void {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      this._buf.queueIndentation(this._indentChar, this._getIndent());\n    }\n  }\n\n  _shouldIndent(firstChar: number) {\n    // we've got a newline before us so prepend on the indentation\n    if (\n      this._indent &&\n      firstChar !== charCodes.lineFeed &&\n      this.endsWith(charCodes.lineFeed)\n    ) {\n      return true;\n    }\n  }\n\n  _maybeAddParenChar(char: number): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    if (char === charCodes.space) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    if (char !== charCodes.lineFeed) {\n      this._parenPushNewlineState = null;\n      return;\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _maybeAddParen(str: string): void {\n    // see startTerminatorless() instance method\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n\n    // This function does two things:\n    // - If needed, prints a parenthesis\n    // - If the currently printed string removes the need for the paren,\n    //   it resets the _parenPushNewlineState field.\n    //   Almost everything removes the need for a paren, except for\n    //   comments and whitespaces.\n\n    const len = str.length;\n\n    let i;\n    for (i = 0; i < len && str.charCodeAt(i) === charCodes.space; i++) continue;\n    if (i === len) {\n      // Whitespaces only, the parentheses might still be needed.\n      return;\n    }\n\n    // Check for newline or comment.\n    const cha = str.charCodeAt(i);\n    if (cha !== charCodes.lineFeed) {\n      if (\n        // This is not a comment (it doesn't start with /)\n        cha !== charCodes.slash ||\n        // This is not a comment (it's a / operator)\n        i + 1 === len\n      ) {\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str.charCodeAt(i + 1);\n\n      if (chaPost === charCodes.asterisk) {\n        // This is a block comment\n\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, len - 2))) {\n          // We avoid printing newlines after #__PURE__ comments (we treat\n          // then as unary operators), but we must keep the old\n          // parenPushNewlineState because, if a newline was forbidden, it is\n          // still forbidden after the comment.\n          return;\n        }\n\n        // NOTE: code flow continues from here to after these if/elses\n      } else if (chaPost !== charCodes.slash) {\n        // This is neither a block comment, nor a line comment.\n        // After a normal token, the parentheses aren't needed anymore\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  catchUp(line: number) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const count = line - this._buf.getCurrentLine();\n\n    for (let i = 0; i < count; i++) {\n      this._newline();\n    }\n  }\n\n  _catchUp(prop: \"start\" | \"end\", loc?: Loc) {\n    if (!this.format.retainLines) return;\n\n    // catch up to this nodes newline if we're behind\n    const line = loc?.[prop]?.line;\n    if (line != null) {\n      const count = line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  /**\n   * Get the current indent.\n   */\n\n  _getIndent(): number {\n    return this._indentRepeat * this._indent;\n  }\n\n  printTerminatorless(node: t.Node, parent: t.Node, isLabel: boolean) {\n    /**\n     * Set some state that will be modified if a newline has been inserted before any\n     * non-space characters.\n     *\n     * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n     *\n     *   return foo;\n     *\n     * returns `foo`. But if we do:\n     *\n     *   return\n     *   foo;\n     *\n     *  `undefined` will be returned and not `foo` due to the terminator.\n     */\n    if (isLabel) {\n      this._noLineTerminator = true;\n      this.print(node, parent);\n    } else {\n      const terminatorState = {\n        printed: false,\n      };\n      this._parenPushNewlineState = terminatorState;\n      this.print(node, parent);\n      /**\n       * Print an ending parentheses if a starting one has been printed.\n       */\n      if (terminatorState.printed) {\n        this.dedent();\n        this.newline();\n        this.token(\")\");\n      }\n    }\n  }\n\n  print(\n    node: t.Node | null,\n    parent?: t.Node,\n    noLineTerminatorAfter?: boolean,\n    // trailingCommentsLineOffset also used to check if called from printJoin\n    // it will be ignored if `noLineTerminatorAfter||this._noLineTerminator`\n    trailingCommentsLineOffset?: number,\n    forceParens?: boolean,\n  ) {\n    if (!node) return;\n\n    this._endsWithInnerRaw = false;\n\n    const nodeType = node.type;\n    const format = this.format;\n\n    const oldConcise = format.concise;\n    if (\n      // @ts-expect-error document _compact AST properties\n      node._compact\n    ) {\n      format.concise = true;\n    }\n\n    const printMethod =\n      this[\n        nodeType as Exclude<\n          t.Node[\"type\"],\n          // removed\n          | \"Noop\"\n          // renamed\n          | t.DeprecatedAliases[\"type\"]\n        >\n      ];\n    if (printMethod === undefined) {\n      throw new ReferenceError(\n        `unknown node of type ${JSON.stringify(\n          nodeType,\n        )} with constructor ${JSON.stringify(node.constructor.name)}`,\n      );\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = node.loc == undefined;\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    const shouldPrintParens =\n      forceParens ||\n      (format.retainFunctionParens &&\n        nodeType === \"FunctionExpression\" &&\n        node.extra?.parenthesized) ||\n      needsParens(node, parent, this._printStack);\n\n    if (shouldPrintParens) {\n      this.token(\"(\");\n      this._endsWithInnerRaw = false;\n    }\n\n    this._lastCommentLine = 0;\n\n    this._printLeadingComments(node, parent);\n\n    const loc = nodeType === \"Program\" || nodeType === \"File\" ? null : node.loc;\n\n    this.exactSource(loc, printMethod.bind(this, node, parent));\n\n    if (shouldPrintParens) {\n      this._printTrailingComments(node, parent);\n      this.token(\")\");\n      this._noLineTerminator = noLineTerminatorAfter;\n    } else if (noLineTerminatorAfter && !this._noLineTerminator) {\n      this._noLineTerminator = true;\n      this._printTrailingComments(node, parent);\n    } else {\n      this._printTrailingComments(node, parent, trailingCommentsLineOffset);\n    }\n\n    // end\n    this._printStack.pop();\n\n    format.concise = oldConcise;\n    this._insideAux = oldInAux;\n\n    this._endsWithInnerRaw = false;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode?: boolean) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n\n    const comment = this.format.auxiliaryCommentBefore;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n\n    const comment = this.format.auxiliaryCommentAfter;\n    if (comment) {\n      this._printComment(\n        {\n          type: \"CommentBlock\",\n          value: comment,\n        },\n        COMMENT_SKIP_NEWLINE.DEFAULT,\n      );\n    }\n  }\n\n  getPossibleRaw(\n    node:\n      | t.StringLiteral\n      | t.NumericLiteral\n      | t.BigIntLiteral\n      | t.DecimalLiteral\n      | t.DirectiveLiteral\n      | t.JSXText,\n  ): string | undefined {\n    const extra = node.extra;\n    if (\n      extra &&\n      extra.raw != null &&\n      extra.rawValue != null &&\n      node.value === extra.rawValue\n    ) {\n      // @ts-expect-error: The extra.raw of these AST node types must be a string\n      return extra.raw;\n    }\n  }\n\n  printJoin(\n    nodes: Array<t.Node> | undefined | null,\n    parent: t.Node,\n    opts: PrintJoinOptions = {},\n  ) {\n    if (!nodes?.length) return;\n\n    let { indent } = opts;\n\n    if (indent == null && this.format.retainLines) {\n      const startLine = nodes[0].loc?.start.line;\n      if (startLine != null && startLine !== this._buf.getCurrentLine()) {\n        indent = true;\n      }\n    }\n\n    if (indent) this.indent();\n\n    const newlineOpts: AddNewlinesOptions = {\n      addNewlines: opts.addNewlines,\n      nextNodeStartLine: 0,\n    };\n\n    const separator = opts.separator ? opts.separator.bind(this) : null;\n\n    const len = nodes.length;\n    for (let i = 0; i < len; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n\n      if (opts.statement) this._printNewline(i === 0, newlineOpts);\n\n      this.print(node, parent, undefined, opts.trailingCommentsLineOffset || 0);\n\n      opts.iterator?.(node, i);\n\n      if (i < len - 1) separator?.();\n\n      if (opts.statement) {\n        if (i + 1 === len) {\n          this.newline(1);\n        } else {\n          const nextNode = nodes[i + 1];\n          newlineOpts.nextNodeStartLine = nextNode.loc?.start.line || 0;\n\n          this._printNewline(true, newlineOpts);\n        }\n      }\n    }\n\n    if (indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node: t.Node, parent: t.Node) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent: Extract<t.Node, { body: t.Statement }>) {\n    const node = parent.body;\n\n    if (node.type !== \"EmptyStatement\") {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node: t.Node, parent?: t.Node, lineOffset?: number) {\n    const { innerComments, trailingComments } = node;\n    // We print inner comments here, so that if for some reason they couldn't\n    // be printed in earlier locations they are still printed *somewhere*,\n    // even if at the end of the node.\n    if (innerComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        innerComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n    if (trailingComments?.length) {\n      this._printComments(\n        COMMENT_TYPE.TRAILING,\n        trailingComments,\n        node,\n        parent,\n        lineOffset,\n      );\n    }\n  }\n\n  _printLeadingComments(node: t.Node, parent: t.Node) {\n    const comments = node.leadingComments;\n    if (!comments?.length) return;\n    this._printComments(COMMENT_TYPE.LEADING, comments, node, parent);\n  }\n\n  _maybePrintInnerComments() {\n    if (this._endsWithInnerRaw) this.printInnerComments();\n    this._endsWithInnerRaw = true;\n    this._indentInnerComments = true;\n  }\n\n  printInnerComments() {\n    const node = this._printStack[this._printStack.length - 1];\n    const comments = node.innerComments;\n    if (!comments?.length) return;\n\n    const hasSpace = this.endsWith(charCodes.space);\n    const indent = this._indentInnerComments;\n    const printedCommentsCount = this._printedComments.size;\n    if (indent) this.indent();\n    this._printComments(COMMENT_TYPE.INNER, comments, node);\n    if (hasSpace && printedCommentsCount !== this._printedComments.size) {\n      this.space();\n    }\n    if (indent) this.dedent();\n  }\n\n  noIndentInnerCommentsHere() {\n    this._indentInnerComments = false;\n  }\n\n  printSequence(\n    nodes: t.Node[],\n    parent: t.Node,\n    opts: PrintSequenceOptions = {},\n  ) {\n    opts.statement = true;\n    opts.indent ??= false;\n    this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items: t.Node[], parent: t.Node, opts: PrintListOptions = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(newLine: boolean, opts: AddNewlinesOptions) {\n    const format = this.format;\n\n    // Fast path since 'this.newline' does nothing when not tracking lines.\n    if (format.retainLines || format.compact) return;\n\n    // Fast path for concise since 'this.newline' just inserts a space when\n    // concise formatting is in use.\n    if (format.concise) {\n      this.space();\n      return;\n    }\n\n    if (!newLine) {\n      return;\n    }\n\n    const startLine = opts.nextNodeStartLine;\n    const lastCommentLine = this._lastCommentLine;\n    if (startLine > 0 && lastCommentLine > 0) {\n      const offset = startLine - lastCommentLine;\n      if (offset >= 0) {\n        this.newline(offset || 1);\n        return;\n      }\n    }\n\n    // don't add newlines at the beginning of the file\n    if (this._buf.hasContent()) {\n      // Here is the logic of the original line wrapping according to the node layout, we are not using it now.\n      // We currently add at most one newline to each node in the list, ignoring `opts.addNewlines`.\n\n      // let lines = 0;\n      // if (!leading) lines++; // always include at least a single line after\n      // if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      // const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      // if (needs(node, parent)) lines++;\n\n      // this.newline(Math.min(2, lines));\n\n      this.newline(1);\n    }\n  }\n\n  // Returns `PRINT_COMMENT_HINT.DEFER` if the comment cannot be printed in this position due to\n  // line terminators, signaling that the print comments loop can stop and\n  // resume printing comments at the next possible position. This happens when\n  // printing inner comments, since if we have an inner comment with a multiline\n  // there is at least one inner position where line terminators are allowed.\n  _shouldPrintComment(comment: t.Comment): PRINT_COMMENT_HINT {\n    // Some plugins (such as flow-strip-types) use this to mark comments as removed using the AST-root 'comments' property,\n    // where they can't manually mutate the AST node comment lists.\n    if (comment.ignore) return PRINT_COMMENT_HINT.SKIP;\n\n    if (this._printedComments.has(comment)) return PRINT_COMMENT_HINT.SKIP;\n\n    if (\n      this._noLineTerminator &&\n      (HAS_NEWLINE.test(comment.value) ||\n        HAS_BlOCK_COMMENT_END.test(comment.value))\n    ) {\n      return PRINT_COMMENT_HINT.DEFER;\n    }\n\n    this._printedComments.add(comment);\n\n    if (!this.format.shouldPrintComment(comment.value)) {\n      return PRINT_COMMENT_HINT.SKIP;\n    }\n\n    return PRINT_COMMENT_HINT.ALLOW;\n  }\n\n  _printComment(comment: t.Comment, skipNewLines: COMMENT_SKIP_NEWLINE) {\n    const noLineTerminator = this._noLineTerminator;\n    const isBlockComment = comment.type === \"CommentBlock\";\n\n    // Add a newline before and after a block comment, unless explicitly\n    // disallowed\n    const printNewLines =\n      isBlockComment &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.ALL &&\n      !this._noLineTerminator;\n\n    if (\n      printNewLines &&\n      this._buf.hasContent() &&\n      skipNewLines !== COMMENT_SKIP_NEWLINE.LEADING\n    ) {\n      this.newline(1);\n    }\n\n    const lastCharCode = this.getLastChar();\n    if (\n      lastCharCode !== charCodes.leftSquareBracket &&\n      lastCharCode !== charCodes.leftCurlyBrace\n    ) {\n      this.space();\n    }\n\n    let val;\n    if (isBlockComment) {\n      val = `/*${comment.value}*/`;\n      if (this.format.indent.adjustMultilineComment) {\n        const offset = comment.loc?.start.column;\n        if (offset) {\n          const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        let indentSize = this.format.retainLines\n          ? 0\n          : this._buf.getCurrentColumn();\n\n        if (this._shouldIndent(charCodes.slash) || this.format.retainLines) {\n          indentSize += this._getIndent();\n        }\n\n        val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n      }\n    } else if (!noLineTerminator) {\n      val = `//${comment.value}`;\n    } else {\n      // It was a single-line comment, so it's guaranteed to not\n      // contain newlines and it can be safely printed as a block\n      // comment.\n      val = `/*${comment.value}*/`;\n    }\n\n    // Avoid creating //* comments\n    if (this.endsWith(charCodes.slash)) this._space();\n\n    this.source(\"start\", comment.loc);\n    this._append(val, isBlockComment);\n\n    if (!isBlockComment && !noLineTerminator) {\n      this.newline(1, true);\n    }\n\n    if (printNewLines && skipNewLines !== COMMENT_SKIP_NEWLINE.TRAILING) {\n      this.newline(1);\n    }\n  }\n\n  _printComments(\n    type: COMMENT_TYPE,\n    comments: readonly t.Comment[],\n    node: t.Node,\n    parent?: t.Node,\n    lineOffset: number = 0,\n  ) {\n    const nodeLoc = node.loc;\n    const len = comments.length;\n    let hasLoc = !!nodeLoc;\n    const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;\n    const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;\n    let lastLine = 0;\n    let leadingCommentNewline = 0;\n\n    const maybeNewline = this._noLineTerminator\n      ? function () {}\n      : this.newline.bind(this);\n\n    for (let i = 0; i < len; i++) {\n      const comment = comments[i];\n\n      const shouldPrint = this._shouldPrintComment(comment);\n      if (shouldPrint === PRINT_COMMENT_HINT.DEFER) {\n        hasLoc = false;\n        break;\n      }\n      if (hasLoc && comment.loc && shouldPrint === PRINT_COMMENT_HINT.ALLOW) {\n        const commentStartLine = comment.loc.start.line;\n        const commentEndLine = comment.loc.end.line;\n        if (type === COMMENT_TYPE.LEADING) {\n          let offset = 0;\n          if (i === 0) {\n            // Because currently we cannot handle blank lines before leading comments,\n            // we always wrap before and after multi-line comments.\n            if (\n              this._buf.hasContent() &&\n              (comment.type === \"CommentLine\" ||\n                commentStartLine != commentEndLine)\n            ) {\n              offset = leadingCommentNewline = 1;\n            }\n          } else {\n            offset = commentStartLine - lastLine;\n          }\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(\n              Math.max(nodeStartLine - lastLine, leadingCommentNewline),\n            );\n            lastLine = nodeStartLine;\n          }\n        } else if (type === COMMENT_TYPE.INNER) {\n          const offset =\n            commentStartLine - (i === 0 ? nodeStartLine : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n\n          if (i + 1 === len) {\n            maybeNewline(Math.min(1, nodeEndLine - lastLine)); // TODO: Improve here when inner comments processing is stronger\n            lastLine = nodeEndLine;\n          }\n        } else {\n          const offset =\n            commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);\n          lastLine = commentEndLine;\n\n          maybeNewline(offset);\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n        }\n      } else {\n        hasLoc = false;\n        if (shouldPrint !== PRINT_COMMENT_HINT.ALLOW) {\n          continue;\n        }\n\n        if (len === 1) {\n          const singleLine = comment.loc\n            ? comment.loc.start.line === comment.loc.end.line\n            : !HAS_NEWLINE.test(comment.value);\n\n          const shouldSkipNewline =\n            singleLine &&\n            !isStatement(node) &&\n            !isClassBody(parent) &&\n            !isTSInterfaceBody(parent) &&\n            !isTSEnumDeclaration(parent);\n\n          if (type === COMMENT_TYPE.LEADING) {\n            this._printComment(\n              comment,\n              (shouldSkipNewline && node.type !== \"ObjectExpression\") ||\n                (singleLine && isFunction(parent, { body: node }))\n                ? COMMENT_SKIP_NEWLINE.ALL\n                : COMMENT_SKIP_NEWLINE.DEFAULT,\n            );\n          } else if (shouldSkipNewline && type === COMMENT_TYPE.TRAILING) {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.ALL);\n          } else {\n            this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n          }\n        } else if (\n          type === COMMENT_TYPE.INNER &&\n          !(node.type === \"ObjectExpression\" && node.properties.length > 1) &&\n          node.type !== \"ClassBody\" &&\n          node.type !== \"TSInterfaceBody\"\n        ) {\n          // class X {\n          //   /*:: a: number*/\n          //   /*:: b: ?string*/\n          // }\n\n          this._printComment(\n            comment,\n            i === 0\n              ? COMMENT_SKIP_NEWLINE.LEADING\n              : i === len - 1\n              ? COMMENT_SKIP_NEWLINE.TRAILING\n              : COMMENT_SKIP_NEWLINE.DEFAULT,\n          );\n        } else {\n          this._printComment(comment, COMMENT_SKIP_NEWLINE.DEFAULT);\n        }\n      }\n    }\n\n    if (type === COMMENT_TYPE.TRAILING && hasLoc && lastLine) {\n      this._lastCommentLine = lastLine;\n    }\n  }\n}\n\n// Expose the node type functions and helpers on the prototype for easy usage.\nObject.assign(Printer.prototype, generatorFunctions);\n\nif (!process.env.BABEL_8_BREAKING) {\n  // @ts-ignore(Babel 7 vs Babel 8) Babel 7 has Noop print method\n  Printer.prototype.Noop = function Noop(this: Printer) {};\n}\n\ntype GeneratorFunctions = typeof generatorFunctions;\ninterface Printer extends GeneratorFunctions {}\nexport default Printer;\n\nfunction commaSeparator(this: Printer) {\n  this.token(\",\");\n  this.space();\n}\n"]},"metadata":{},"sourceType":"script"}